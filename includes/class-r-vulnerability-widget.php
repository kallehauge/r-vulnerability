<?php

namespace Rommel;

use Rommel\WpVulnDb\Client;

/**
 * R_Vulnerability_Widget.
 *
 * @TODO...
 */
class R_Vulnerability_Widget {

	/**
	 * The Widget ID.
	 *
	 * @var string
	 */
	protected $id;

	/**
	 * The name/title of the widget.
	 *
	 * @var string
	 */
	protected $name;

	/**
	 * The client to make requests to "WPScan Vulnerability Database".
	 *
	 * @var \Rommel\WpVulnDb\Client
	 */
	protected $client;

	/**
	 * List of active plugin files.
	 *
	 * @var array
	 */
	protected $active_plugin_files;

	/**
	 * Constructor.
	 *
	 * @param string $text_domain
	 *   The text domain for the plugin.
	 * @param \Rommel\WpVulnDb\Client $client
	 *   The client to make requests to "WPScan Vulnerability Database".
	 * @param array $active_plugin_files
	 *   List of absolute paths to plugin files.
	 */
	public function __construct( $text_domain, Client $client, $active_plugin_files = [] ) {
		$this->id = 'r_vulnerabilities';
		$this->name =  __( 'Vulnerabilities', $text_domain );
		$this->client = $client;

		// Get all active plugins - since we're not interested in inactive
		// plugins because their files aren't included during the bootstrap.
		$this->active_plugin_files = ! empty( $active_plugin_files ) ? $active_plugin_files : wp_get_active_and_valid_plugins();
	}

	/**
	 * @TODO...
	 */
	public function init() {
		wp_add_dashboard_widget(
			$this->id,
			$this->name,
			[ $this, 'display' ]
		);
	}

	/**
	 * @TODO...
	 */
	public function display() {
		foreach ( $this->get_new_vulnerabilities() as $plugin ) {
			echo $plugin['name'] . ': ' . $plugin['status'];
			echo '<br>';
		}
	}

	/**
	 * @TODO...
	 */
	protected function get_new_vulnerabilities() {
		$new_vulnerabilities = [];

		foreach ( $this->get_plugin_data() as $name => $plugin ) {
			$vulnerabilities = $this->get_plugin_vulnerabilities( $name );
			if ( ! empty( $vulnerabilities ) ) {
				// @TODO There are some "Fixed in" values that are NULL so we have
				// to implement some defensive coding that will keep crawling until
				// we find an actual update - or make a "warning" instead of an
				// error to indicate that it have to be checked manually.
				$latest_update = $vulnerabilities[0]['fixed_in'];

				// Check if the vulnerability is newer than the current plugin
				// version.
				! $this->compare_version_numbers( $plugin['Version'], $latest_update ) ?: $new_vulnerabilities[ $name ] = [
					'name' => $plugin['Name'],
					'status' => 'Not secure',
				];
			}
		}

		return $new_vulnerabilities;
	}

	/**
	 * Compares two "PHP-standardized" version number strings.
	 *
	 * @param string $current
	 *   The current plugin version.
	 * @param string $update
	 *   The latest security update version.
	 *
	 * @return boolean
	 *   Will return TRUE if the current plugin version is newer than the
	 *   security update.
	 */
	protected function compare_version_numbers( $current, $update ) {
		return (bool) version_compare( $current, $update );
	}

	/**
	 * @TODO ...
	 *
	 * @param string $plugin_name
	 *
	 * @return array
	 */
	protected function get_plugin_vulnerabilities( $plugin_name ) {
		$response = $this->client->getPlugin( $plugin_name );
		$vulnerabilities = $response ? current( $response )['vulnerabilities'] : [];

		// Reverse the vulnerabilities since the latest update will be at the
		// bottom of the returned array.
		return array_reverse( $vulnerabilities );
	}

	/**
	 * Populate all active plugins with data.
	 *
	 * @TODO...
	 */
	protected function get_plugin_data() {
		$plugins = [];
		foreach ( $this->active_plugin_files as $plugin ) {
			if ( file_exists( $plugin ) ) {
				// We want to get the plugin name based on the path since it
				// isn't provided in the plugin data.
				// We can explode the string for each slash, then the name will
				// always be the second item in the array.
				// String format: "/var/www/.../plugins/name/name.php".
				$plugin_name = array_reverse( explode( '/', $plugin ) )[1];

				// Populate the array with 'name' => [data].
				$plugins[ $plugin_name ] = get_plugin_data( $plugin );
			}
		}

		return $plugins;
	}

}
